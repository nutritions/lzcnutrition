## JAVA SE

### idea使用

ctrl+alt+t：生成包裹选中代码的代码块，比如if else，try catch

alt+回车：快速生成返回值

alt+shift+enter:导包







### 数组的内存

声明的在栈，new的数组在堆，相当于数组名在栈，类似指针指向new在堆中的数组

 ![image-20250407220624135](assets/image-20250407220624135.png)

### 构造器

在类被实例化时用于初始化值，alt+insert生成构造器

必须和类名相同 

定义也会有默认的构造器，是无参构造

**一旦有了有参构造，如果要使用无参构造，则需要显式定义无参构造** 



### 类，实例化的内存情况

类是引用类型，实例化的对象是通过引用来操作的，由栈->堆

![image-20250409121503697](assets/image-20250409121503697.png)



### 重写

- 需要有继承关系

- 子类重写父类的方法

- 方法名和参数列表必须相同 （区别于重载：参数列表必须不同）

  只是代码实现不同

- 修饰符：子类重写范围只能不变或者扩大

- 抛出的异常：范围可以被缩小不能扩大

- 不能是static的

  > 因为static的方法属于类本身，并不依赖于实例化的对象，和类名相关联的
  >
  > ![image-20250410005644490](assets/image-20250410005644490.png)
  >
  > 而重写要求子类和父类对一个方法名有不同的代码实现，是依赖于实例化后的对象的
  >
  > ![image-20250410005607085](assets/image-20250410005607085.png)





### 多态

条件：

- 继承

- 子类重写父类方法

- 父类引用指向子类对象

  > new可以确定一个对象的实际类型
  >
  > 但可以由父类去指向这个对象
  >
  > **在调用重写方法时调用的是子类对象的方法，没有重写就调用的是父类的方法**
  >
  > （这样才能实现父类可以调用多个子类相同名字和参数的方法，实现多态）
  >
  > 例如，student继承自person，new student确定对象是student，但是可以person p1指向这个student



### static

static修饰的和类一起加载，要早于不带static修饰的属性和方法，因此可以直接使用类名调用

没有static修饰的属性和方法，在没有实例化之前是不能被调用的





### 抽象类

（存在构造器）

![image-20250410101333196](assets/image-20250410101333196.png)

 意义：

- 强制子类实现所有的抽象方法
- 明确设计意图，抽象类作为基类
- 避免实例化无用的对象（抽象类不能被实例化）





### 接口

接口不能被实例化，没有构造方法

接口只给出规范，不实现，没有方法体

![image-20250410105646044](assets/image-20250410105646044.png)

类可以实现多个接口

![image-20250410105622391](assets/image-20250410105622391.png)

### 异常

当做对象来处理

![image-20250411004330287](assets/image-20250411004330287.png)

类型：不确定错误类型可以从throwable开始catch

![image-20250411004348850](assets/image-20250411004348850.png)

可以捕捉多个异常，类似if else的关系 

![image-20250411004601585](assets/image-20250411004601585.png)

## JAVAweb

### mysql





### JDBC

java数据库连接，使用java操作关系型数据库的一套api

![image-20251102185600274](assets/image-20251102185600274.png)



### maven

#### maven作用

![image-20251102193954575](assets/image-20251102193954575.png)

![image-20251102200548898](assets/image-20251102200548898.png)

#### maven配置依赖作用范围

![image-20251105191225640](assets/image-20251105191225640.png)

### 单元测试

Jnuit测试框架：自动化测试，生成测试报告

![image-20251105123332531](assets/image-20251105123332531.png)

![image-20251105123441818](assets/image-20251105123441818.png)

![image-20251105124951735](assets/image-20251105124951735.png)

断言辅助测试是否正确：

![QQ_1762337133502](assets/QQ_1762337133502.png)

其他注解：

![image-20251105183504781](assets/image-20251105183504781.png)

### web基础

#### springboot

![image-20251105235502562](assets/image-20251105235502562.png)



#### HTTP协议

超文本传输协议，规定了浏览器与服务器之间数据传输的规则

![image-20251106012231535](assets/image-20251106012231535.png)

> 请求数据格式

![image-20251106012856672](assets/image-20251106012856672.png)

> 请求数据获取

浏览器发起请求到服务端，服务端对请求数据进行处理

![image-20251106013235970](assets/image-20251106013235970.png)

![image-20251106014041746](assets/image-20251106014041746.png)

> 响应数据格式

![image-20251106120928919](assets/image-20251106120928919.png)

> 响应数据设置

![image-20251106120954030](assets/image-20251106120954030.png)

![image-20251106121345194](assets/image-20251106121345194.png)

#### 分层解耦

> 三层架构

![image-20251106150305683](assets/image-20251106150305683.png)

#### 解耦

![image-20251107004518019](assets/image-20251107004518019.png)

![image-20251107005037305](assets/image-20251107005037305.png)

两个注释：

@Component：将当前类交给IOC容器管理（加在实现类上，不是接口上）

@Autowired：只需要定义成员变量，不需要new，执行时会自动查询容器，将对应的bean对象赋值给成员变量



> IOC详解

![image-20251107011739900](assets/image-20251107011739900.png)

![image-20251107011537688](assets/image-20251107011537688.png)

> DI详解

如果对接口进行了多个实现类，都由IOC容器进行管理：

![image-20251107012821410](assets/image-20251107012821410.png)